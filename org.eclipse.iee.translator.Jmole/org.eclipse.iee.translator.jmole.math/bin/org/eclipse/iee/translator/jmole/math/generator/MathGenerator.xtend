/*
 * generated by Xtext
 */
package org.eclipse.iee.translator.jmole.math.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess

import org.eclipse.iee.translator.jmole.math.math

import org.eclipse.xtext.xtend2.lib.StringConcatenation
import static extension org.eclipse.xtext.xtend2.lib.ResourceExtensions.*
import org.eclipse.iee.translator.jmole.math.math.*

class MathGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

	}
	
	def String generateText(Resource resource) {
		var statements = resource.allContentsIterable.filter(typeof(Statement));
		
		if (statements.empty) {
			return null;
		}
		
		return statements.head.compileStatement.toString();	
	}
	
	def compileStatement(Statement s)
	{
	'''	
		«IF s.functionDefinition != null»«compileFunctionDefinition(s.functionDefinition)»«ENDIF»
		«IF s.variableAssignment != null»«compileVariableAssignment(s.variableAssignment)»;«ENDIF»
		«IF s.matrixAssignment != null»«compileMatrixAssignment(s.matrixAssignment)»;«ENDIF»
		«IF s.formula != null»«compileFormula(s.formula)»;«ENDIF»
		«IF s.matrixFormula != null»«compileMatrixFormula(s.matrixFormula)»;«ENDIF»
	'''
	}
	
	def compileFunctionDefinition(FunctionDefinition funcDef)
	{
	'''
		public static double «funcDef.function.name» ( 
		«FOR param:funcDef.function.parameters»
		 «IF param != null»double «compileFormula(param)»«ENDIF»
		 «IF funcDef.function.parameters.last() != param»,«ENDIF»
		«ENDFOR») 
		{ «IF funcDef.formula != null» return «compileFormula(funcDef.formula)»;«ENDIF» }
	'''
	}
	
	def compileVariableAssignment(VariableAssignment a)
	{
	 '''
	 	«a.variable» = «compileFormula(a.value)»
	 '''
	}
	
	def compileFormula(Formula f) 
	{
	'''
		«compileExpression(f.expression)»
	'''
	}
	
	def compileMatrixFormula(MatrixFormula f) 
	{
	'''
		«compileMatrixExpression(f.expression)»
	'''
	}
	
	def compileMatrixAssignment(MatrixAssignment a)
	{
	 '''
	 	«a.variable» = «compileMatrixFormula(a.value)»
	 '''
	}
	
	def compileFunction(Function f) '''
		«f.function.name»
		(«FOR param:f.function.parameters»
		 «IF param != null»«compileFormula(param)»«ENDIF»
		 «IF f.function.parameters.last() != param»,«ENDIF»
		«ENDFOR»)
	'''
	
	//Expressions
		
	def dispatch compileExpression(Variable n) '''
		«n.name»'''
		
	def dispatch compileExpression(Float n) '''
		«n.value»'''
		
	def dispatch compileExpression(MatrixElement e) '''
		«e.element».get(«e.row»,«e.column»)'''	
		
	def dispatch compileExpression(Function f) '''
		«compileFunction(f)»'''
	
	def dispatch compileExpression(Addition op) '''
		(«compileExpression(op.left)») + («compileExpression(op.right)»)'''
	
	def dispatch compileExpression(Subtraction op) '''
		(«compileExpression(op.left)») - («compileExpression(op.right)»)'''
	
	def dispatch compileExpression(Multiplication op) '''
		(«compileExpression(op.left)») * («compileExpression(op.right)»)'''
	
	def dispatch compileExpression(Division op) '''
		(«compileExpression(op.left)») / («compileExpression(op.right)»)'''
	
	def dispatch compileExpression(Modulo op) '''
		(«compileExpression(op.left)») % («compileExpression(op.right)»)'''
	
	def dispatch compileExpression(Invert op) '''
	«IF op.expression != null» (-(«compileExpression(op.expression)»)) «ENDIF»''' 
	
	def dispatch compileExpression(Factorial op) '''
	«IF op.expression != null» («compileExpression(op.expression)»)! «ENDIF»'''  
	
	def dispatch compileExpression(Exponent op) '''
		Math.pow((«compileExpression(op.left)»),(«compileExpression(op.right)»))'''
	
	//Matrix Expressions
	def dispatch compileMatrixExpression(MatrixVariable n) '''
		«n.name»'''
		
	def dispatch compileMatrixExpression(NewMatrix m) '''
		new Matrix(new double[][]
		{
		«var j = 0»
		«FOR row:m.matrix.rows»
		 «IF row != null»
		 {
		 	«var i = 0»
	 		«FOR element:row.elements»
			 «IF element != null»
			 	«element»
			 «ENDIF»
			 «IF (i = i + 1) != row.elements.size()»,«ENDIF»
			«ENDFOR»
		 }
		 «ENDIF»
		 «IF (j = j + 1) != m.matrix.rows.size()»,«ENDIF»
		«ENDFOR»
		})'''	
	
	def dispatch compileMatrixExpression(TransposeMatrix n) '''
		«n.name».transpose()'''		
		
	def dispatch compileMatrixExpression(MatrixAddition op) '''
		«compileMatrixExpression(op.left)».plus(«compileMatrixExpression(op.right)»)'''
	
	def dispatch compileMatrixExpression(MatrixSubtraction op) '''
		«compileMatrixExpression(op.left)».minus(«compileMatrixExpression(op.right)»)'''
	
	def dispatch compileMatrixExpression(MatrixMultiplication op) '''
		«IF op.rightMatrix != null»«compileMatrixExpression(op.left)».times(«compileMatrixExpression(op.rightMatrix)»)«ENDIF»
		«IF op.rightScalar != null»«compileMatrixExpression(op.left)».times(«compileFormula(op.rightScalar)»)«ENDIF»'''
	 	
}