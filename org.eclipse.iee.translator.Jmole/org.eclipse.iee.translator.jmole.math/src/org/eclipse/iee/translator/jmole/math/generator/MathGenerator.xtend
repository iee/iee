/*
 * generated by Xtext
 */
package org.eclipse.iee.translator.jmole.math.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.iee.translator.jmole.math.math.*

class MathGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

	}
	
	def String generateText(Resource resource) {
		var statements = resource.contents;
		
		if (statements.empty) {
			return null;
		}
		
		var statement = compileStatement(statements.head as Statement);
		
		return statement.toString();	
	}
	
	def compileStatement(Statement s)
	{
	'''	
		«IF s.functionDefinition != null»«compileFunctionDefinition(s.functionDefinition)»«ENDIF»
		«IF s.variableAssignment != null»«compileVariableAssignment(s.variableAssignment)»;«ENDIF»
		«IF s.matrixAssignment != null»«compileMatrixAssignment(s.matrixAssignment)»;«ENDIF»
		«IF s.formula != null»«compileFormula(s.formula)»«ENDIF»
		«IF s.logicalFormula != null»«compileLogicalFormula(s.logicalFormula)»«ENDIF»
		«IF s.matrixFormula != null»«compileMatrixFormula(s.matrixFormula)»«ENDIF»
	'''
	}
	
	def compileFunctionDefinition(FunctionDefinition funcDef)
	{
	'''
		public static double «compileName(funcDef.function.name)» ( 
		«FOR param:funcDef.function.parameters»
		 «IF param != null»double «compileFormula(param)»«ENDIF»
		 «IF funcDef.function.parameters.last() != param»,«ENDIF»
		«ENDFOR») 
		{ «IF funcDef.formula != null» return «compileFormula(funcDef.formula)»;«ENDIF» }
	'''
	}
	
	def compileName(MathName name)
	{
	'''
		«var temp = name.mathName»
		«temp.replaceAll("\\{", "").replaceAll("\\}", "")»
	'''
	}
	
	def compileVariableAssignment(VariableAssignment a)
	{
	 '''
	 	«compileFormula(a.variable)» = «compileFormula(a.value)»
	 '''
	}
	
	def compileFormula(Formula f) 
	{
	'''
		«compileExpression(f.expression)»
	'''
	}
	
	def compileLogicalFormula(LogicalFormula f) 
	{
	'''
		«compileLogicalExpression(f.expression)»
	'''
	}
	
	def compileMatrixFormula(MatrixFormula f) 
	{
	'''
		«compileMatrixExpression(f.expression)»
	'''
	}
	
	def compileMatrixAssignment(MatrixAssignment a)
	{
	 '''
	 	«compileName(a.variable)» = «compileMatrixFormula(a.value)»
	 '''
	}
	
	def compileFunction(Function f) '''
		«compileName(f.function.name)»
		(«FOR param:f.function.parameters»
		 «IF param != null»«compileFormula(param)»«ENDIF»
		 «IF f.function.parameters.last() != param»,«ENDIF»
		«ENDFOR»)
	'''
	
	//Expressions
		
	def dispatch compileExpression(Variable n) '''
		«compileName(n.name)»'''
		
	def dispatch compileExpression(Float n) '''
		«n.value»'''
		
	def dispatch compileExpression(MatrixElement e) '''
		«compileName(e.element)».get(«compileFormula(e.row)»,«compileFormula(e.column)»)'''	
		
	def dispatch compileExpression(Function f) '''
		«compileFunction(f)»'''
		
	def dispatch compileExpression(ClassFunction call) '''
		«compileName(call.class_)».«compileName(call.function.name)»
		(«FOR param:call.function.parameters»
		 «IF param != null»«compileFormula(param)»«ENDIF»
		 «IF call.function.parameters.last() != param»,«ENDIF»
		«ENDFOR»)'''
		
	def dispatch compileExpression(ClassMember call) '''
		«compileName(call.class_)».«compileName(call.member)»'''	
	
	def dispatch compileExpression(Addition op) '''
		(«compileExpression(op.left)») + («compileExpression(op.right)»)'''
	
	def dispatch compileExpression(Subtraction op) '''
		(«compileExpression(op.left)») - («compileExpression(op.right)»)'''
	
	def dispatch compileExpression(Multiplication op) '''
		(«compileExpression(op.left)») * («compileExpression(op.right)»)'''
	
	def dispatch compileExpression(Division op) '''
		(«compileExpression(op.left)») / («compileExpression(op.right)»)'''
	
	def dispatch compileExpression(Modulo op) '''
		(«compileExpression(op.left)») % («compileExpression(op.right)»)'''
	
	def dispatch compileExpression(Invert op) '''
	«IF op.expression != null» (-(«compileExpression(op.expression)»)) «ENDIF»''' 
	
	def dispatch compileExpression(Factorial op) '''
	«IF op.expression != null» («compileExpression(op.expression)»)! «ENDIF»'''  
	
	def dispatch compileExpression(Exponent op) '''
		Math.pow((«compileExpression(op.left)»),(«compileExpression(op.right)»))'''
	
	//Matrix Expressions
	def dispatch compileMatrixExpression(MatrixVariable n) '''
		«compileName(n.name)»'''
		
	def dispatch compileMatrixExpression(NewMatrix m) '''
		new Matrix(new double[][]
		{
		«var j = 0»
		«FOR row:m.matrix.rows»
		 «IF row != null»
		 {
		 	«var i = 0»
	 		«FOR element:row.elements»
			 «IF element != null»
			 	«compileFormula(element)»
			 «ENDIF»
			 «IF (i = i + 1) != row.elements.size()»,«ENDIF»
			«ENDFOR»
		 }
		 «ENDIF»
		 «IF (j = j + 1) != m.matrix.rows.size()»,«ENDIF»
		«ENDFOR»
		})'''	
	
	def dispatch compileMatrixExpression(TransposeMatrix n) '''
		«compileName(n.name)».transpose()'''		
		
	def dispatch compileMatrixExpression(MatrixAddition op) '''
		«compileMatrixExpression(op.left)».plus(«compileMatrixExpression(op.right)»)'''
	
	def dispatch compileMatrixExpression(MatrixSubtraction op) '''
		«compileMatrixExpression(op.left)».minus(«compileMatrixExpression(op.right)»)'''
	
	def dispatch compileMatrixExpression(MatrixMultiplication op) '''
		«IF op.rightMatrix != null»«compileMatrixExpression(op.left)».times(«compileMatrixExpression(op.rightMatrix)»)«ENDIF»
		«IF op.rightScalar != null»«compileMatrixExpression(op.left)».times(«compileFormula(op.rightScalar)»)«ENDIF»'''
	
	//Logical Expressions
		
	def dispatch compileLogicalExpression(LogicalAddition op) '''
		(«compileLogicalExpression(op.left)») || («compileLogicalExpression(op.right)»)'''
	
	def dispatch compileLogicalExpression(LogicalMultiplication op) '''
		(«compileLogicalExpression(op.left)») && («compileLogicalExpression(op.right)»)'''
		
	 def dispatch compileLogicalExpression(LogicalComparison op) '''
		(«compileFormula(op.left)») «op.operation» («compileFormula(op.right)»)'''	
}